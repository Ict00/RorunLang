### Самая пьяная документация для языка Волшебства
# Rorun Lang (Kii 2)

## Общая Информация
Rorun Lang (aka **Kii 2**) - Язык "программирования", хоть и несколько не логичен.

Код на данном языке поделён на **Блоки**

У каждого блока есть "Промежуточная" память и Временная память.
Промежуточная память - это те же аргументы. Данная информация примерно никак не повляет на процесс разработки. :)

У каждого блока также есть **Модификаторы**, вернее один из: late, early, crate.
Все они связаны с очисткой памяти. Early отчищает память в начале исполнения блока, но не в конце; late его точная противоположность, а при crate память вообще не очищается. (На данный момент все эти подробности тоже не обязательны)

Вот так записываются блоки:
```c
block main
{
    ...
}
```

Также в Rorun есть **Структуры**. По факту это просто набор полей.
```c
struct ExampleStruct
[
    Field1
    Field2
    ...
]
```

В Rorun из **Типов** пока есть только: int (число), str (строка), структуры и списки. 

Конкретно весь код работает благодаря **Операторам**. Это основа. Функций в данном языке так таковых нет. Операторы, очевидно, бывают Унарные и Бинарные.

## Операторы

В языке на данный момент есть довольно много операторов. Вот и они:

* ### Println/outln
> Выводит данную ему информацию с переносом строки, может быть как унарным, так и бинарным.
* ### Print/out
> Точно то же самое, что и println/outln, только без переноса строки
* ### Математические (+-*/)
> Очевидно (Работают некорректно!!!)
* ### Логические (>= <= > < == != ! && ||)
> Очевидно
* ### Присваивания (= /= *= += -=)
> Тоже очевидно, НО! В качестве названия переменной может выступать что угодно и можно переопределять числа.
* ### Группировки (, и `)
> , Группирует данные в виде списка, с заменой элементов на их значения из памяти (т.е. если есть переменная 'a' и она передана в оператор группировки, то она будет заменена на значение из памяти)

> ` Группирует данные в виде списка БЕЗ замены (именная группировка)
* ### Для работы со списками (.. at len ]+ ]-)
> (Индекс) at (список) - получить элемент списка

> len (список) - длина списка

> (Первый элемент)..(Последний элемент) - создаёт список со значениями от первого до второго включительно
> т.е 1..10 вернёт список [1,2,3,4,5,6,7,8,9,10]

> (список) ]+ (элемент) добавить новый элемент списка

> (список) ]- (индекс) удалить элемент из списка по индексу

> (список) map (блок, принимающий 1 аргумент) - применяет к каждому элементу списка блок и возвращает изменённый список

> (список/строка) has (элемент/строка) - возвращет true/false в зависимости от того, есть ли элемент в списке/есть ли строка в строке
* ### As
> (переменная/значение) as (тип (str/int))
* ### Del
> Удаляет указанную переменную
* ### Format
> (строка (формата "{0}, {1}...")) format список элементов - форматирование
* ### Get
> get (переменная с названием другой переменной/название другой переменной) - получение другой переменной (не знаю как описать, типа кривые указатели)
* ### Do
> (оператор для выполнения типа строки) do (список аргументов) - выполнение указанного оператора со списком аргументов
* ### Jsonit
> jsonit (что угодно) - преобразование переданного в JSON
* ### Rev
> rev (значение) - даёт название переменной по значению в формате грубой строки (т.е. "название"), если таковых переменных несколько, то выбирается случайная
* ### Destr
> destr (строка) - Переводит грубую строку в нормальную
* ### In
> in (переменная) - Чтение ввода в переменную
* ### Операторы выполнения блоков (run, runif, :, =>)
> run (блок) - вызывает блок по названию без аргументов (возвращает либо ^, либо возвращаемое значение блока)

> (условие) runif (блок, если условие - true), (блок, если условие - false (опционально)) - очевидно

> (блок) : (аргументы в виде списка) - передаёт аргументы в блок и вызывает его; возвращает возвращаемое блоком значение или ^

> (переменные в виде списка/лишь один) => (блок/список блоков) - вызов блока или нескольких блоков с несколькими или одной переменной в аргументах соответственно. Ничего не возвращает
* ### ->
> (переменная/переменные) -> (блок) - передаёт переменные в блок в качестве аргументов
* ### Args
> args (переменная1 ` переменная2...) - получение аргументов. Используется на стороне вызываемых блоков:
```cs
block main
{
    args a; // Или args a ` b ` c...
}
```
* ### Return
> return (переменная/значение) - возвращает значение.
* ### Instance
> (название структуры) instance (данные, передаваемые структуры) - создаёт экземпляр структуры
* ### Cast
> (экземпляр структуры) cast (название структуры) - перевести одну структуру в другой тип по схожим полям. если у исходной структуры нет таких полей, какие есть у конечной, то они будут равны 0. Если у конечной нет таких полей, как у исходной, то такие поля учтены не будут.
* ### Destruct
> destruct (структура) - возвращает данные экземпляра структуры в виде списка (работает плохо) и удаляет его из памяти
* ### .
> (Экземпляр структуры).(Поле) - обращение к полю структуры
* ### import
> import (файл с расширением .rr/.kii/не имеющий расширения) - импорт содержимого

# ЗАПУСК
Для запуска необходим **.NET 8**. Установите его.

После, скопируйте репозиторий, откройте папку, в которой есть **RorunLang.csproj** И запустите
```cs 
dotnet build
```
после, в директории bin/Debug/net8.0/ будет RorunLang.exe. Его можно запускать:
```cs 
RorunLang.exe исполняемый файл
```
Либо поместите файл main.rr/main.kii в одной директории с RorunLang.exe